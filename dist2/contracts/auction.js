"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AUCTION_CONTRACT = " //------------------------------------------------------------------------------\n//\n//   Copyright 2019 Fetch.AI Limited\n//\n//   Licensed under the Apache License, Version 2.0 (the \"License\");\n//   you may not use this file except in compliance with the License.\n//   You may obtain a copy of the License at\n//\n//       http://www.apache.org/licenses/LICENSE-2.0\n//\n//   Unless required by applicable law or agreed to in writing, software\n//   distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//   See the License for the specific language governing permissions and\n//   limitations under the License.\n//\n//------------------------------------------------------------------------------\n\n// This contract require release v0.9.1 or above\n// Note that this is experimental functionality\n\npersistent beneficiary : Address;\npersistent auctionEndTime : UInt64;\npersistent highestBidder : Address;\npersistent highestBid : UInt64;\npersistent sharded pendingReturns : UInt64;\npersistent ended : Bool;\n\n\n@init\nfunction constructor(benefitAddr: Address)\n\n    use beneficiary;\n    use auctionEndTime;\n    use highestBidder;\n    use highestBid;\n\n    beneficiary.set(benefitAddr);\n    var now : UInt64 = getContext().block().blockNumber();\n    var biddingTime : UInt64 = 200u64;\n    auctionEndTime.set(now + biddingTime);\n\n    highestBidder.set(null);\n    highestBid.set(0u64);\n\nendfunction\n\n\n@action\nfunction bid()\n\n    use auctionEndTime;\n    use highestBid;\n\n    var tx = getContext().transaction();\n    var sender_addr = tx.from();\n    var sender_value = tx.getTotalTransferAmount();\n    var now = getContext().block().blockNumber();\n\n    assert(now <= auctionEndTime.get(), \"Auction already ended.\");\n    assert(sender_value > highestBid.get(), \"There already is a higher bid.\");\n\n    if(highestBid.get() != 0u64)\n        var highestBidderAddress = highestBidder.get();\n        use pendingReturns[highestBidderAddress];\n        pendingReturns.set(highestBidderAddress, highestBid.get());\n        // pendingReturns.set(highestBidderAddress, currentPendingReturns + highestBid.get());\n    endif\n\n    highestBidder.set(sender_addr);\n    highestBid.set(sender_value);\n\nendfunction\n\n\n@action\nfunction withdraw(): Bool\n\n    var tx = getContext().transaction();\n    var receiver_addr = tx.from();\n    use pendingReturns[receiver_addr];\n\n    var amount : UInt64 = pendingReturns.get(receiver_addr);\n    if(amount > 0u64)\n        pendingReturns.set(receiver_addr, 0u64);\n\n        if(!receiver_addr.send(amount))\n            pendingReturns.set(receiver_addr, amount);\n            return false;\n        endif\n\n    endif\n    return true;\n\nendfunction\n\n\n@action\nfunction endAuction()\n\n    use auctionEndTime;\n    use ended;\n    use beneficiary;\n    use highestBid;\n\n    var now = getContext().block().blockNumber();\n\n    assert(now >= auctionEndTime.get(), \"Auction not yet ended.\");\n    assert(!ended.get(), \"auctionEnd has already been called.\");\n    ended.set(true);\n    transfer(beneficiary.get(), highestBid.get());\n\nendfunction";
exports.AUCTION_CONTRACT = AUCTION_CONTRACT;
//# sourceMappingURL=auction.js.map