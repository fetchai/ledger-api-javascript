<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: crypto/entity.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: crypto/entity.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {randomBytes} from 'crypto'
import * as secp256k1 from 'secp256k1'
import {ValidationError} from '../errors'
import {Identity} from './identity'
import * as  fs from 'fs'

/**
 * An entity is a full private/public key pair.
 *
 * @public
 * @class
 */
export class Entity extends Identity {

    constructor(private_key_bytes) {

        // construct or generate the private key if one is not specified
        if (private_key_bytes) {
            if (secp256k1.privateKeyVerify(private_key_bytes)) {
                const pubKey = Buffer.from(secp256k1.publicKeyCreate(private_key_bytes, false).toString('hex').substring(2), 'hex')
                super(pubKey)
                this.pubKey = pubKey
                this.privKey = private_key_bytes

            } else {
                throw new ValidationError(
                    'Unable to load private key from input'
                )
            }
        } else {
            let privKey
            let pubKey
            do {
                privKey = randomBytes(32)
                pubKey = Buffer.from(secp256k1.publicKeyCreate(privKey, false).toString('hex').substring(2), 'hex')
            } while (!secp256k1.privateKeyVerify(privKey))
            super(pubKey)
            this.pubKey = pubKey
            this.privKey = privKey
        }
    }

    private_key() {
        return this.privKey
    }

    private_key_hex() {
        return this.privKey.toString('hex')
    }


    public_key_hex() {
        return this.pubKey.toString('hex')
    }

    // sign the message. returns sign obj
    sign(extMsgHash) {
        return secp256k1.sign(extMsgHash, this.privKey)
    }

    signature_hex(sigObj) {
        return sigObj.signature.toString('hex')
    }

    _to_json_object() {
        const base64 = this.privKey.toString('base64')
        return JSON.parse(`{"privateKey": "${base64}"}`)
    }

    static from_base64(private_key_base64) {
        const private_key_bytes = Buffer.from(private_key_base64, 'base64')
        return new Entity(private_key_bytes)
    }

    static _from_json_object(obj) {
        return Entity.from_base64(obj.privateKey)
    }

    static from_hex(private_key_hex) {
        const private_key_bytes = Buffer.from(private_key_hex, 'hex')
        return new Entity(private_key_bytes)
    }

    static loads(s) {
        const obj = JSON.parse(s)
        return Entity._from_json_object(obj)
    }

    static load(fp) {
        const obj = JSON.parse(fs.readFileSync(fp, 'utf8'))
        return Entity._from_json_object(obj)
    }

    /**
     * add missed dumps methods
     */
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ApiEndpoint.html">ApiEndpoint</a></li><li><a href="BitVector.html">BitVector</a></li><li><a href="Entity.html">Entity</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_calculate_log2_num_bytes">_calculate_log2_num_bytes</a></li><li><a href="global.html#encode">encode</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Wed Nov 27 2019 13:25:42 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
